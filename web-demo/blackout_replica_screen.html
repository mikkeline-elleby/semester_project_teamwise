<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Daily + Tavus Custom UI</title>
  <style>
    :root {
      --bg-dark: #0b1021;
      --bg-panel: #0e152d;
      --border: #1c2540;
      --text: #f2f4ff;
      --accent: #4fd1c5;
      --danger: #e53e3e;
    }
    body { font-family: system-ui, -apple-system, sans-serif; margin: 0; height: 100vh; background: var(--bg-dark); color: var(--text); display: flex; flex-direction: column; overflow: hidden; }
    
    /* Layout */
    #app-container { display: flex; flex: 1; overflow: hidden; position: relative; }
    #main-stage { flex: 1; background: #000; display: flex; align-items: center; justify-content: center; position: relative; }
    #sidebar { width: 260px; background: var(--bg-panel); border-left: 1px solid var(--border); overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 10px; }
    #controls-bar { height: 60px; background: var(--bg-panel); border-top: 1px solid var(--border); display: flex; align-items: center; justify-content: center; gap: 16px; padding: 0 20px; }
    
    /* Header / Config Area */
    #config-panel { padding: 10px 20px; background: var(--bg-panel); border-bottom: 1px solid var(--border); display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    #config-panel input { background: var(--bg-dark); border: 1px solid var(--border); color: var(--text); padding: 6px 10px; border-radius: 4px; width: 200px; }
    #config-panel button { padding: 6px 12px; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; font-size: 13px; }
    .btn-primary { background: var(--accent); color: var(--bg-dark); }
    .btn-danger { background: var(--danger); color: white; }
    .btn-secondary { background: #4a5568; color: white; }
    
    /* Video Tiles */
    .video-tile { background: #222; border-radius: 8px; overflow: hidden; position: relative; aspect-ratio: 16/9; width: 100%; }
    .video-tile video { width: 100%; height: 100%; object-fit: cover; }
    .video-tile .label { position: absolute; bottom: 6px; left: 6px; background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 4px; font-size: 11px; pointer-events: none; }
    
    /* Stage Video */
    #stage-video-container { width: 100%; height: 100%; max-width: 1280px; max-height: 720px; position: relative; }
    #stage-video { width: 100%; height: 100%; object-fit: contain; }
    #stage-label { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 6px 12px; border-radius: 6px; font-size: 14px; }
    
    /* Controls */
    .ctrl-btn { width: 44px; height: 44px; border-radius: 50%; border: none; background: #2d3748; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: background 0.2s; }
    .ctrl-btn:hover { background: #4a5568; }
    .ctrl-btn.active { background: var(--accent); color: var(--bg-dark); }
    .ctrl-btn.danger { background: var(--danger); }

    /* Logs */
    #log-panel { height: 150px; background: #080c19; border-top: 1px solid var(--border); overflow-y: auto; padding: 10px; font-family: monospace; font-size: 12px; color: #a0aec0; }
    
    /* Utilities */
    .hidden { display: none !important; }
  </style>
  <script src="https://unpkg.com/@daily-co/daily-js"></script>
</head>
<body>

  <!-- Top Config Panel -->
  <div id="config-panel">
    <input id="conversation-url" placeholder="Conversation URL" />
    <input id="display-name" placeholder="Your Name" value="Guest" />
    <button id="join-btn" class="btn-primary">Join</button>
    <div style="width: 1px; height: 20px; background: #333; margin: 0 8px;"></div>
    <button id="start-btn" class="btn-secondary" disabled>Start Icebreaker</button>
    <button id="replica-off-btn" class="btn-danger" disabled>Replica Off</button>
    <button id="replica-stop-btn" class="btn-danger" disabled>Stop Speaking</button>
    <div style="width: 1px; height: 20px; background: #333; margin: 0 8px;"></div>
    <button id="record-btn" class="btn-secondary" disabled>‚è∫ Record</button>
    <div style="flex:1"></div>
    <div style="font-size: 12px; color: #666;">Tavus Custom UI</div>
  </div>

  <!-- Main Layout -->
  <div id="app-container">
    <!-- Center Stage -->
    <div id="main-stage">
      <div id="stage-video-container" class="hidden">
        <video id="stage-video" autoplay playsinline></video>
        <div id="stage-label">Active Speaker</div>
      </div>
      <div id="stage-placeholder" style="color: #555;">Waiting for participants...</div>
    </div>

    <!-- Right Sidebar -->
    <div id="sidebar">
      <!-- Tiles injected here -->
    </div>
  </div>

  <!-- Bottom Controls -->
  <div id="controls-bar">
    <button id="btn-mic" class="ctrl-btn" title="Toggle Mic">üé§</button>
    <button id="btn-cam" class="ctrl-btn" title="Toggle Camera">üì∑</button>
    <button id="btn-screen" class="ctrl-btn" title="Share Screen">üñ•Ô∏è</button>
    <div style="width: 20px;"></div>
    <button id="btn-leave" class="ctrl-btn danger" title="Leave Call">üìû</button>
  </div>

  <!-- Logs -->
  <div id="log-panel"></div>

  <!-- Hidden Audio Container for Remote Participants -->
  <div id="audio-container" style="display:none;"></div>

  <script>
    // --- Configuration & State ---
    const facilKeywords = ["assistant", "facilitator", "meeting facilitator", "teamwise"];
    let callObject = null;
    let conversationId = null;
    let participants = {}; // Local roster state
    let activeSpeakerId = null;
    let screenShareId = null;
    
    // Tavus State
    let executedPhases = new Set();
    let replicaDisabled = false;
    let ignoreToolCalls = false;
    let echoQueue = [];
    let echoSending = false;
    let replicaSpeaking = false;
    let nextSendNotBefore = 0;
    let onEchoIdleCallbacks = [];
    let speakCounts = {};
    let lastSpokenPeerId = null;
    let lastSpokenName = null;
    let recordingState = { active: false, id: null };

    // Round Robin State
    let roundState = {
      active: false, stepKey: null, queue: [], currentId: null,
      completed: new Set(), responses: [], promptFn: null,
      allowOutOfOrder: true, pendingStart: false
    };

    // --- UI Elements ---
    const logEl = document.getElementById("log-panel");
    const stageContainer = document.getElementById("stage-video-container");
    const stageVideo = document.getElementById("stage-video");
    const stageLabel = document.getElementById("stage-label");
    const stagePlaceholder = document.getElementById("stage-placeholder");
    const sidebar = document.getElementById("sidebar");
    const audioContainer = document.getElementById("audio-container");
    
    // Buttons
    const joinBtn = document.getElementById("join-btn");
    const startBtn = document.getElementById("start-btn");
    const replicaOffBtn = document.getElementById("replica-off-btn");
    const replicaStopBtn = document.getElementById("replica-stop-btn");
    const recordBtn = document.getElementById("record-btn");
    const btnMic = document.getElementById("btn-mic");
    const btnCam = document.getElementById("btn-cam");
    const btnScreen = document.getElementById("btn-screen");
    const btnLeave = document.getElementById("btn-leave");

    // --- Logging ---
    function logLine(msg) {
      const line = document.createElement("div");
      line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    // --- Helpers ---
    function parseConversationId(url) {
      try {
        const u = new URL(url);
        const parts = u.pathname.split("/").filter(Boolean);
        return parts[0] || null;
      } catch (e) { return null; }
    }

    function isFacilName(nm) {
      return facilKeywords.some((k) => (nm || "").toLowerCase().includes(k));
    }

    function isReplica(p) {
      return !p.local && isFacilName(p.user_name);
    }

    function getTrack(p, type) {
      const t = p?.tracks?.[type];
      return (t && t.state === "playable") ? t.persistentTrack : null;
    }

    // --- Rendering Logic ---
    function updateUI() {
      if (!callObject) return;
      
      const allParticipants = Object.values(callObject.participants());
      const local = allParticipants.find(p => p.local);
      
      // 1. Manage Audio (Standalone elements for everyone remote)
      // This ensures we hear everyone, including the invisible replica
      allParticipants.forEach(p => {
        if (p.local) return; // Local audio handled by browser/system
        
        // If replica is disabled, strictly enforce silence by ignoring its track
        if (replicaDisabled && isReplica(p)) {
            const existing = document.getElementById(`audio-${p.session_id}`);
            if (existing) existing.remove();
            return;
        }

        let audioEl = document.getElementById(`audio-${p.session_id}`);
        const audioTrack = getTrack(p, "audio");
        
        if (audioTrack) {
          if (!audioEl) {
            audioEl = document.createElement("audio");
            audioEl.id = `audio-${p.session_id}`;
            audioEl.autoplay = true;
            audioContainer.appendChild(audioEl);
          }
          const stream = new MediaStream([audioTrack]);
          if (audioEl.srcObject?.id !== stream.id) {
            audioEl.srcObject = stream;
          }
        } else {
          if (audioEl) audioEl.remove();
        }
      });

      // 2. Determine Stage Participant
      // Priority: Screen Share -> Active Speaker -> Local User
      let stageP = null;
      
      // Check for screen share
      const screenSharer = allParticipants.find(p => getTrack(p, "screenVideo"));
      if (screenSharer) {
        stageP = { p: screenSharer, track: getTrack(screenSharer, "screenVideo"), isScreen: true };
      } else {
        // Check active speaker (must be human)
        const speaker = allParticipants.find(p => p.session_id === activeSpeakerId);
        if (speaker && !isReplica(speaker)) {
          stageP = { p: speaker, track: getTrack(speaker, "video"), isScreen: false };
        } else {
          // Fallback to local or first human
          const fallback = local || allParticipants.find(p => !isReplica(p));
          if (fallback) {
            stageP = { p: fallback, track: getTrack(fallback, "video"), isScreen: false };
          }
        }
      }

      // Render Stage
      if (stageP && stageP.track) {
        stageContainer.classList.remove("hidden");
        stagePlaceholder.classList.add("hidden");
        
        const stream = new MediaStream([stageP.track]);
        if (stageVideo.srcObject?.id !== stream.id) {
          stageVideo.srcObject = stream;
        }
        stageLabel.textContent = stageP.p.user_name + (stageP.isScreen ? " (Screen)" : "");
      } else {
        stageContainer.classList.add("hidden");
        stagePlaceholder.classList.remove("hidden");
        stagePlaceholder.textContent = "No active video";
      }

      // 3. Render Sidebar (All Humans)
      // We rebuild the list or update existing to keep order? 
      // Simple approach: Sync DOM with list
      const humans = allParticipants.filter(p => !isReplica(p));
      
      // Remove stale
      Array.from(sidebar.children).forEach(el => {
        const id = el.dataset.id;
        if (!humans.find(p => p.session_id === id)) el.remove();
      });

      // Add/Update
      humans.forEach(p => {
        let tile = document.getElementById(`tile-${p.session_id}`);
        if (!tile) {
          tile = document.createElement("div");
          tile.className = "video-tile";
          tile.id = `tile-${p.session_id}`;
          tile.dataset.id = p.session_id;
          tile.innerHTML = `<video autoplay playsinline muted></video><div class="label"></div>`;
          sidebar.appendChild(tile);
        }
        
        const vid = tile.querySelector("video");
        const label = tile.querySelector(".label");
        
        label.textContent = p.user_name + (p.local ? " (You)" : "");
        
        const track = getTrack(p, "video");
        if (track) {
          const stream = new MediaStream([track]);
          if (vid.srcObject?.id !== stream.id) vid.srcObject = stream;
          vid.style.opacity = "1";
        } else {
          vid.style.opacity = "0"; // Hide video element if no track, keep tile
        }
        
        // Highlight active speaker in sidebar
        if (p.session_id === activeSpeakerId) {
          tile.style.border = "2px solid var(--accent)";
        } else {
          tile.style.border = "none";
        }
      });
    }

    // --- Daily Events ---
    function wireEvents(call) {
      const events = ["participant-joined", "participant-updated", "participant-left", "track-started", "track-stopped"];
      events.forEach(e => call.on(e, updateUI));

      // Recording Events
      call.on("recording-started", (e) => {
        recordingState.active = true;
        recordingState.id = e.recordingId;
        updateRecordUI();
        logLine("Recording STARTED");
      });
      call.on("recording-stopped", () => {
        recordingState.active = false;
        recordingState.id = null;
        updateRecordUI();
        logLine("Recording STOPPED");
      });
      call.on("recording-error", (e) => logLine(`Recording Error: ${e.errorMsg}`));

      call.on("active-speaker-change", (ev) => {
        activeSpeakerId = ev.activeSpeaker?.peerId;
        updateUI();
        
        // Tavus Logic Hook
        const p = ev.activeSpeaker?.peerId ? call.participants()[ev.activeSpeaker.peerId] : null;
        if (p) registerRoster(p, true);
      });

      // Transcription & Tavus Logic
      call.on("transcription-message", handleTranscription);
      call.on("app-message", handleAppMessage);
      
      // Controls State
      call.on("participant-updated", (ev) => {
        if (ev.participant.local) updateControlsState(ev.participant);
      });
    }

    function updateControlsState(p) {
      const audio = p.audio;
      const video = p.video;
      const screen = p.screen;
      
      btnMic.classList.toggle("active", audio);
      btnMic.textContent = audio ? "üé§" : "mic_off";
      
      btnCam.classList.toggle("active", video);
      btnCam.textContent = video ? "üì∑" : "videocam_off";
      
      btnScreen.classList.toggle("active", screen);
    }

    function updateRecordUI() {
      if (recordingState.active) {
        recordBtn.textContent = "‚èπ Stop Rec";
        recordBtn.classList.remove("btn-secondary");
        recordBtn.classList.add("btn-danger");
      } else {
        recordBtn.textContent = "‚è∫ Record";
        recordBtn.classList.remove("btn-danger");
        recordBtn.classList.add("btn-secondary");
      }
    }

    // --- Tavus Logic (Restored) ---

    // Helpers
    function rememberParticipant(p) {
      if (!p) return null;
      const id = p.session_id || p.peerId || p.id || null;
      const name = p.user_name || p.name || p.user_id || (id ? `user-${id.slice(-5)}` : "Unknown");
      if (id) participants[id] = { id, name };
      const key = id || (name ? `name:${name.toLowerCase()}` : null);
      if (key) {
        const existing = speakCounts[key] || { id, name, count: 0 };
        speakCounts[key] = { ...existing, id: id || existing.id, name: name || existing.name };
      }
      return id ? { id, name } : null;
    }

    function bumpSpeakCount(id, name) {
      const key = id || (name ? `name:${name.toLowerCase()}` : null);
      if (!key) return;
      const existing = speakCounts[key] || { id, name, count: 0 };
      speakCounts[key] = { id: id || existing.id, name: name || existing.name, count: (existing.count || 0) + 1 };
    }

    function participantFromId(id) {
      return participants[id] || null;
    }

    function currentSpeaker() {
      if (lastSpokenPeerId && participants[lastSpokenPeerId]) {
        return { name: participants[lastSpokenPeerId].name, confident: true };
      }
      if (lastSpokenName) return { name: lastSpokenName, confident: true };
      return { name: "", confident: false };
    }

    function leastActiveParticipant() {
      Object.values(participants).forEach((p) => {
        const key = p.id || (p.name ? `name:${p.name.toLowerCase()}` : null);
        if (key && !speakCounts[key]) {
          speakCounts[key] = { id: p.id, name: p.name, count: 0 };
        }
      });
      const entries = Object.values(speakCounts).filter((e) => e && e.name && !isFacilName(e.name));
      if (!entries.length) {
        const fallback = Object.values(participants).find((p) => p.name && !isFacilName(p.name));
        return fallback ? { ...fallback, count: 0 } : null;
      }
      entries.sort((a, b) => (a.count || 0) - (b.count || 0));
      return entries[0];
    }

    function getHumanParticipants() {
      return Object.values(participants).filter((p) => p?.name && !isFacilName(p.name));
    }

    function namesTextFromParticipants() {
      const names = getHumanParticipants().map(p => p.name).filter(Boolean);
      let namesText = "everyone";
      if (names.length === 1) namesText = names[0];
      else if (names.length === 2) namesText = `${names[0]} and ${names[1]}`;
      else if (names.length > 2) namesText = `${names.slice(0, -1).join(", ")}, and ${names[names.length - 1]}`;
      return namesText;
    }

    // Echo Queue Helpers
    function estimateSpeechMs(text) {
      const words = (text || "").trim().split(/\s+/).filter(Boolean).length;
      const punctuation = (text.match(/[.,!?;:]/g) || []).length;
      const base = 700;
      const perWord = 380;
      const perPunct = 120;
      const total = base + words * perWord + punctuation * perPunct;
      return Math.max(900, Math.min(total, 22000));
    }

    function afterEchoIdle(fn) {
      if (typeof fn !== "function") return;
      let executed = false;
      const safeFn = () => {
        if (executed) return;
        executed = true;
        fn();
      };
      onEchoIdleCallbacks.push(safeFn);
      setTimeout(() => {
        if (!executed) {
          if (replicaSpeaking) replicaSpeaking = false;
          const idx = onEchoIdleCallbacks.indexOf(safeFn);
          if (idx !== -1) onEchoIdleCallbacks.splice(idx, 1);
          safeFn();
        }
      }, 6000);
      pumpEchoQueue();
    }

    function runEchoIdleCallbacksIfReady() {
      if (echoQueue.length === 0 && !echoSending && !replicaSpeaking) {
        const callbacks = onEchoIdleCallbacks.slice();
        onEchoIdleCallbacks = [];
        callbacks.forEach((cb) => { try { cb(); } catch (e) { logLine(`Error: ${e}`); } });
      }
    }

    // Round Robin Engine
    function buildQueue(strategy = "joined") {
      const people = getHumanParticipants();
      if (!people.length) return [];
      if (strategy === "random") {
        const ids = people.map(p => p.id);
        for (let i = ids.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [ids[i], ids[j]] = [ids[j], ids[i]];
        }
        return ids;
      }
      if (strategy === "least_active_first") {
        people.forEach((p) => {
          const key = p.id || `name:${p.name.toLowerCase()}`;
          if (!speakCounts[key]) speakCounts[key] = { id: p.id, name: p.name, count: 0 };
        });
        const scored = people.map((p) => {
          const key = p.id || `name:${p.name.toLowerCase()}`;
          return { id: p.id, count: speakCounts[key]?.count || 0 };
        });
        scored.sort((a, b) => a.count - b.count);
        return scored.map(s => s.id);
      }
      return people.map(p => p.id);
    }

    function beginRound(stepKey, promptFn, opts = {}) {
      roundState.active = true;
      roundState.stepKey = stepKey;
      roundState.promptFn = promptFn;
      roundState.completed = new Set();
      roundState.responses = [];
      roundState.allowOutOfOrder = opts.allowOutOfOrder ?? true;
      roundState.queue = buildQueue(opts.queueStrategy || "least_active_first");
      
      let firstPrompt = "";
      let firstId = null;
      if (roundState.queue.length > 0) {
        firstId = roundState.queue[0];
        const p = participants[firstId];
        if (p) firstPrompt = promptFn(p.name || "there");
      }

      const intro = opts.introText || "";
      const fullScript = [intro, firstPrompt].filter(Boolean).join(" ");
      if (fullScript) enqueueEcho(fullScript, opts.inferenceId);

      roundState.currentId = firstId;
      roundState.pendingStart = false;
      logLine(`Round started: ${stepKey}`);
    }

    function triggerNextPhase(currentPhase) {
      let nextTool = null;
      if (currentPhase === "intro") nextTool = "start_picnic_game";
      else if (currentPhase === "picnic_game") nextTool = "start_morning_enjoyment_round";
      else if (currentPhase === "morning_enjoyment") nextTool = "start_fun_skill_round";
      else if (currentPhase === "fun_skill") nextTool = "start_shared_preference_task";
      else if (currentPhase === "shared_preference_tea_coffee") nextTool = "transition_to_next_session";

      if (nextTool) {
        logLine(`Auto-advancing to ${nextTool}...`);
        afterEchoIdle(() => handleToolCall({ properties: { name: nextTool } }));
      }
    }

    function promptNext() {
      if (!roundState.active) return;
      if (roundState.pendingStart) return;

      const nextId = roundState.queue.find(id => !roundState.completed.has(id));
      if (!nextId) {
        roundState.active = false;
        roundState.currentId = null;
        const phaseName = roundState.stepKey.replace(/_/g, " ");
        enqueueEcho(`Thanks everyone ‚Äî the ${phaseName} round is complete.`);
        triggerNextPhase(roundState.stepKey);
        return;
      }

      roundState.currentId = nextId;
      const p = participants[nextId];
      const promptText = roundState.promptFn?.(p?.name || "there") || "";
      if (promptText) enqueueEcho(promptText);
    }

    function markComplete(participant_id, display_name, text) {
      logLine(`Marked complete: ${display_name}`);
      roundState.completed.add(participant_id);
      roundState.responses.push({ stepKey: roundState.stepKey, participant_id, display_name, text, ts: Date.now() });
    }

    function resetRound() {
      roundState.active = false;
      roundState.stepKey = null;
      roundState.queue = [];
      roundState.currentId = null;
      roundState.completed = new Set();
      roundState.responses = [];
      roundState.promptFn = null;
      roundState.allowOutOfOrder = true;
      roundState.pendingStart = false;
    }

    // Event Handlers
    function handleTranscription(ev) {
      const msg = ev.message || ev;
      const text = msg.text || "";
      const pid = typeof msg.participant === "string" ? msg.participant : msg.participant?.session_id;
      
      if (msg.is_final && text) {
        const p = callObject.participants()[pid];
        const name = p?.user_name || "Unknown";
        logLine(`[CC] ${name}: ${text}`);
        
        if (p) {
            registerRoster(p, true);
            lastSpokenPeerId = pid;
            lastSpokenName = name;
        }

        // "What's my name?" helper
        const textLower = (text || "").toLowerCase();
        if ((textLower.includes("what") && textLower.includes("my name")) ||
            (textLower.includes("who") && textLower.includes("am i")) ||
            (textLower.includes("my name"))) {
          if (lastSpokenName) enqueueEcho(`You are ${lastSpokenName}`);
        }

        // Start Trigger
        if (executedPhases.size === 0) {
             const words = textLower.split(/\s+/);
             if (words.includes("start") || words.includes("begin") || textLower.includes("let's start")) {
                 handleToolCall({ properties: { name: "initiate_introduction" } });
             }
        }

        // Round Robin Logic
        if (roundState.active && pid && !isFacilName(name)) {
            const spokenText = (text || "").trim();
            if (spokenText.length > 1) {
              const isExpected = pid === roundState.currentId;
              if (isExpected || roundState.allowOutOfOrder) {
                if (!roundState.completed.has(pid)) {
                  markComplete(pid, name, spokenText);
                  enqueueEcho(`Thanks, ${name}.`);
                  promptNext();
                }
              }
            }
        }
      }
    }

    function handleAppMessage(ev) {
      const data = ev?.data || {};
      
      if (data.event_type === "conversation.interrupt") {
          applyReplicaStopLocally();
          return;
      }

      if (data.event_type === "conversation.tool_call") handleToolCall(data);
      if (data.event_type?.includes("started_speaking")) {
          replicaSpeaking = true;
          logLine("Replica speaking...");
      }
      if (data.event_type?.includes("stopped_speaking")) {
          replicaSpeaking = false;
          pumpEchoQueue();
          runEchoIdleCallbacksIfReady();
      }
    }

    function handleToolCall(event) {
      if (ignoreToolCalls) return;
      const { properties = {}, inference_id: inferenceId } = event || {};
      const name = properties.name;
      logLine(`Tool Call: ${name}`);
      
      if (name === "get_current_speaker") {
        const { name, confident } = currentSpeaker();
        if (name && confident) enqueueEcho(`Acknowledged: ${name} has spoken.`, inferenceId);
        return;
      }
      if (name === "get_least_active_participant") {
        const least = leastActiveParticipant();
        if (least?.name) enqueueEcho(`Call on ${least.name} next.`, inferenceId);
        return;
      }
      if (name === "initiate_introduction") {
        if (executedPhases.has("intro")) return;
        executedPhases.add("intro");
        const namesText = namesTextFromParticipants();
        const script = `Hi ${namesText}, welcome. I‚Äôm TeamWise. I‚Äôm not human ‚Äî but I‚Äôm very good at helping humans work well together. We‚Äôll start with a few short, light exercises.`;
        enqueueEcho(script, inferenceId);
        triggerNextPhase("intro");
        return;
      }
      if (name === "start_picnic_game") {
        if (executedPhases.has("picnic")) return;
        executedPhases.add("picnic");
        const script = `Let‚Äôs start with names in a playful way. Please say your name and something you‚Äôd bring to a picnic that starts with the same letter.`;
        beginRound("picnic_game", (n) => `${n}, you‚Äôre up.`, { queueStrategy: "joined", allowOutOfOrder: false, introText: script, inferenceId });
        return;
      }
      if (name === "start_morning_enjoyment_round") {
        if (executedPhases.has("morning")) return;
        executedPhases.add("morning");
        beginRound("morning_enjoyment", (n) => `${n}, what‚Äôs one thing you enjoy in the morning?`, { introText: "Great. Let‚Äôs do a quick round. What‚Äôs one thing you enjoy in the morning?", inferenceId });
        return;
      }
      if (name === "start_fun_skill_round") {
        if (executedPhases.has("fun_skill")) return;
        executedPhases.add("fun_skill");
        beginRound("fun_skill", (n) => `${n}, what‚Äôs a fun skill you have?`, { introText: "One more individual round. What‚Äôs a fun skill you have?", inferenceId });
        return;
      }
      if (name === "start_shared_preference_task") {
        if (executedPhases.has("shared_pref")) return;
        executedPhases.add("shared_pref");
        beginRound("shared_preference_tea_coffee", (n) => `${n}, tea or coffee?`, { introText: "To finish, let‚Äôs do something together. Tea or coffee?", inferenceId });
        return;
      }
      if (name === "transition_to_next_session") {
        if (executedPhases.has("transition")) return;
        executedPhases.add("transition");
        enqueueEcho("Perfect. We‚Äôve learned each other‚Äôs names. Let‚Äôs take this relaxed mindset into the next session.", inferenceId);
        resetRound();
        return;
      }
    }

    function enqueueEcho(text, inferenceId) {
      if (replicaDisabled) return;
      if (!text || !String(text).trim()) return;
      echoQueue.push({ text: String(text), inferenceId });
      pumpEchoQueue();
    }

    function pumpEchoQueue() {
      if (replicaDisabled || echoSending || replicaSpeaking || echoQueue.length === 0) {
        runEchoIdleCallbacksIfReady();
        return;
      }
      const now = Date.now();
      if (now < nextSendNotBefore) {
        setTimeout(pumpEchoQueue, Math.max(60, nextSendNotBefore - now));
        return;
      }
      const item = echoQueue.shift();
      echoSending = true;
      
      if (callObject) {
        callObject.sendAppMessage({
          message_type: "conversation",
          event_type: "conversation.echo",
          conversation_id: conversationId,
          properties: { text: item.text, modality: "text", done: true, inference_id: item.inferenceId }
        }, "*");
        logLine(`Echo sent: ${item.text}`);
      }
      
      const holdMs = estimateSpeechMs(item.text);
      nextSendNotBefore = Date.now() + holdMs;
      setTimeout(() => { echoSending = false; pumpEchoQueue(); runEchoIdleCallbacksIfReady(); }, holdMs);
    }

    async function registerRoster(p, active = false) {
      const entry = rememberParticipant(p);
      if (!entry || !conversationId) return;
      if (active) {
        lastSpokenPeerId = entry.id;
        lastSpokenName = entry.name;
        bumpSpeakCount(entry.id, entry.name);
      }
      const body = { conversation_id: conversationId, display_name: entry.name, participant_id: entry.id, active };
      try {
        const base = "http://localhost:8000"; // Hardcoded for now as input might be far
        await fetch(`${base}/roster/register`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
      } catch (err) { }
    }

    // --- Button Actions ---
    joinBtn.onclick = async () => {
      const url = document.getElementById("conversation-url").value;
      const name = document.getElementById("display-name").value;
      conversationId = parseConversationId(url);

      if (!url || !conversationId) return alert("Invalid URL or ID");
      
      joinBtn.disabled = true;
      
      callObject = window.DailyIframe.createCallObject();
      wireEvents(callObject);
      
      try {
        await callObject.join({ url, userName: name });
        logLine("Joined!");
        startBtn.disabled = false;
        replicaOffBtn.disabled = false;
        replicaStopBtn.disabled = false;
        recordBtn.disabled = false;
        updateUI();
      } catch (e) {
        logLine(`Error: ${e}`);
        joinBtn.disabled = false;
      }
    };

    startBtn.onclick = () => handleToolCall({ properties: { name: "initiate_introduction" } });

    replicaOffBtn.onclick = () => {
      replicaDisabled = true;
      ignoreToolCalls = true;
      echoQueue = [];
      logLine("Replica Disabled.");
      
      // Mute replica subscription
      const all = callObject.participants();
      Object.values(all).forEach(p => {
        if (isReplica(p)) {
           callObject.updateParticipant(p.session_id, { setAudio: false, setVideo: false });
           logLine(`Muted replica: ${p.user_name}`);
        }
      });
      replicaOffBtn.textContent = "Replica Off (Active)";
      replicaOffBtn.disabled = true;
    };

    // --- Stop Speaking Logic ---
    function applyReplicaStopLocally() {
      if (replicaDisabled) return;
      replicaDisabled = true;
      ignoreToolCalls = true;
      echoQueue = [];
      echoSending = false;
      replicaSpeaking = false;
      
      logLine("STOP SPEAKING triggered. Silencing replica.");

      if (callObject) {
        const all = callObject.participants();
        Object.values(all).forEach(p => {
          if (isReplica(p)) {
             callObject.updateParticipant(p.session_id, { setAudio: false, setVideo: false });
             logLine(`Unsubscribed from replica: ${p.user_name}`);
          }
        });
      }
      
      if (replicaStopBtn) {
          replicaStopBtn.textContent = "Stop Speaking (Active)";
          replicaStopBtn.disabled = true;
      }
      if (replicaOffBtn) {
          replicaOffBtn.textContent = "Replica Off (Active)";
          replicaOffBtn.disabled = true;
      }
    }

    function broadcastReplicaStop() {
        if (!callObject || !conversationId) return;
        logLine("Sending Tavus Interrupt...");
        callObject.sendAppMessage({
            message_type: "conversation",
            event_type: "conversation.interrupt",
            conversation_id: conversationId
        }, "*");
    }

    replicaStopBtn.onclick = () => {
        broadcastReplicaStop();
        applyReplicaStopLocally();
    };

    recordBtn.onclick = async () => {
      if (!callObject) return;
      recordBtn.disabled = true;
      try {
        if (recordingState.active) {
           logLine("Stopping recording...");
           await callObject.stopRecording();
        } else {
           logLine("Starting recording...");
           await callObject.startRecording();
        }
      } catch (e) {
        logLine(`Recording Action Failed: ${e}`);
      }
      recordBtn.disabled = false;
    };

    btnMic.onclick = () => callObject.setLocalAudio(!callObject.participants().local.audio);
    btnCam.onclick = () => callObject.setLocalVideo(!callObject.participants().local.video);
    btnScreen.onclick = () => {
       const local = callObject.participants().local;
       if (local.screen) callObject.stopScreenShare();
       else callObject.startScreenShare();
    };
    btnLeave.onclick = async () => {
       await callObject.leave();
       callObject.destroy();
       callObject = null;
       sidebar.innerHTML = "";
       stageVideo.srcObject = null;
       joinBtn.disabled = false;
       logLine("Left call.");
    };

  </script>
</body>
</html>