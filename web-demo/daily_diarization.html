<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Daily + Tavus diarization helper</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 16px; line-height: 1.4; background: #0b1021; color: #f2f4ff; }
    h1 { margin: 0 0 12px; font-size: 22px; }
    label { display: block; margin: 8px 0 4px; font-weight: 600; }
    input { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid #29304a; background: #11172f; color: #f2f4ff; }
    button { margin-top: 12px; padding: 10px 14px; border: none; border-radius: 8px; background: #4fd1c5; color: #0b1021; font-weight: 700; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 8px; }
    @media (min-width: 900px) { .row { grid-template-columns: 320px 1fr; } }
    #call { width: 100%; min-height: 500px; background: #0e152d; border: 1px solid #1c2540; border-radius: 10px; overflow: hidden; }
    #log { background: #0e152d; border: 1px solid #1c2540; border-radius: 10px; padding: 10px; height: 260px; overflow-y: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .note { font-size: 13px; color: #9eb0e0; margin-top: 6px; }
  </style>
  <script src="https://unpkg.com/@daily-co/daily-js"></script>
</head>
<body>
  <h1>Daily diarization → Tavus roster helper</h1>
  <div class="row">
    <div>
      <label for="conversation-url">Conversation URL (from tune.py)</label>
      <input id="conversation-url" placeholder="https://tavus.daily.co/abcdef123456" />
      <label for="webhook-base">Webhook base (FastAPI)</label>
      <input id="webhook-base" value="http://localhost:8000" />
      <label for="display-name">Your display name</label>
      <input id="display-name" placeholder="Alex" />
      <button id="join-btn">Join and listen</button>
      <div class="note">Ensure the conversation config has enable_closed_captions=true. Start your FastAPI webhook (uvicorn app.main:app).</div>
      <div class="note">We post participant info to /roster/register to keep Tavus tools diarization-aware.</div>
      <div class="note">This version uses an echo queue to prevent the replica from getting cut off by back-to-back echoes.</div>
    </div>
    <div id="call"></div>
  </div>
  <label style="margin-top:16px;">Event log</label>
  <div id="log"></div>

  <script>
    const logEl = document.getElementById("log");
    const convoInput = document.getElementById("conversation-url");
    const webhookInput = document.getElementById("webhook-base");
    const nameInput = document.getElementById("display-name");
    const joinBtn = document.getElementById("join-btn");

    let frame = null;
    let conversationId = null;
    let participants = {};
    let lastActivePeerId = null;
    let lastSpokenPeerId = null;
    let lastSpokenName = null;
    let speakCounts = {};
    let startScriptSent = false;
    let executedPhases = new Set();

    // --- Round-robin icebreaker state ---
    let roundState = {
      active: false,
      stepKey: null,
      queue: [],
      currentId: null,
      completed: new Set(),
      responses: [],
      promptFn: null,
      allowOutOfOrder: true,
      pendingStart: false, // wait until replica is quiet + echo queue is idle
    };

    // ---------- Logging ----------
    function logLine(msg) {
      const line = document.createElement("div");
      line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function parseConversationId(url) {
      try {
        const u = new URL(url);
        const parts = u.pathname.split("/").filter(Boolean);
        return parts[0] || null;
      } catch (e) {
        return null;
      }
    }

    // ---------- Helpers: participants & filtering ----------
    const facilKeywords = ["assistant", "facilitator", "meeting facilitator", "teamwise"];
    function isFacilName(nm) {
      return facilKeywords.some((k) => nm?.toLowerCase().includes(k));
    }

    function rememberParticipant(p) {
      if (!p) return null;
      const id = p.session_id || p.peerId || p.id || null;
      const name = p.user_name || p.name || p.user_id || (id ? `user-${id.slice(-5)}` : "Unknown");
      if (id) participants[id] = { id, name };
      const key = id || (name ? `name:${name.toLowerCase()}` : null);
      if (key) {
        const existing = speakCounts[key] || { id, name, count: 0 };
        speakCounts[key] = { ...existing, id: id || existing.id, name: name || existing.name };
      }
      return id ? { id, name } : null;
    }

    function bumpSpeakCount(id, name) {
      const key = id || (name ? `name:${name.toLowerCase()}` : null);
      if (!key) return;
      const existing = speakCounts[key] || { id, name, count: 0 };
      speakCounts[key] = { id: id || existing.id, name: name || existing.name, count: (existing.count || 0) + 1 };
    }

    async function registerRoster(p, active = false) {
      const entry = rememberParticipant(p);
      if (!entry || !conversationId) return;
      if (active) {
        lastSpokenPeerId = entry.id;
        lastSpokenName = entry.name;
        bumpSpeakCount(entry.id, entry.name);
      }
      const body = {
        conversation_id: conversationId,
        display_name: entry.name,
        participant_id: entry.id,
        active,
      };
      try {
        const base = webhookInput.value.replace(/\/$/, "");
        await fetch(`${base}/roster/register`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        logLine(`Roster updated: ${entry.name} (${entry.id})${active ? " [active]" : ""}`);
      } catch (err) {
        logLine(`Failed to POST /roster/register: ${err}`);
      }
    }

    function participantFromId(id) {
      return participants[id] || null;
    }

    function currentSpeaker() {
      if (lastSpokenPeerId && participants[lastSpokenPeerId]) {
        return { name: participants[lastSpokenPeerId].name, confident: true };
      }
      if (lastSpokenName) return { name: lastSpokenName, confident: true };
      return { name: "", confident: false };
    }

    function leastActiveParticipant() {
      Object.values(participants).forEach((p) => {
        const key = p.id || (p.name ? `name:${p.name.toLowerCase()}` : null);
        if (key && !speakCounts[key]) {
          speakCounts[key] = { id: p.id, name: p.name, count: 0 };
        }
      });
      const entries = Object.values(speakCounts).filter((e) => e && e.name && !isFacilName(e.name));
      if (!entries.length) {
        const fallback = Object.values(participants).find((p) => p.name && !isFacilName(p.name));
        return fallback ? { ...fallback, count: 0 } : null;
      }
      entries.sort((a, b) => (a.count || 0) - (b.count || 0));
      return entries[0];
    }

    function getHumanParticipants() {
      return Object.values(participants).filter((p) => p?.name && !isFacilName(p.name));
    }

    function namesTextFromParticipants() {
      const names = getHumanParticipants().map(p => p.name).filter(Boolean);
      let namesText = "everyone";
      if (names.length === 1) namesText = names[0];
      else if (names.length === 2) namesText = `${names[0]} and ${names[1]}`;
      else if (names.length > 2) namesText = `${names.slice(0, -1).join(", ")}, and ${names[names.length - 1]}`;
      return namesText;
    }

    // =========================================================
    // Echo queue (prevents the replica getting cut off)
    // =========================================================
    let echoQueue = []; // { text, inferenceId }
    let echoSending = false;
    let replicaSpeaking = false;   // best-effort, based on app-message events
    let nextSendNotBefore = 0;     // simple throttle
    let onEchoIdleCallbacks = [];  // run when queue empty AND replica not speaking

    function estimateSpeechMs(text) {
      // Roughly 150 wpm => ~400ms per word. Add base + punctuation padding.
      const words = (text || "").trim().split(/\s+/).filter(Boolean).length;
      const punctuation = (text.match(/[.,!?;:]/g) || []).length;
      const base = 700;
      const perWord = 380;
      const perPunct = 120;
      const total = base + words * perWord + punctuation * perPunct;
      // Clamp a bit so tiny messages still get a gap, huge ones don't block forever.
      return Math.max(900, Math.min(total, 22000));
    }

    function sendEchoNow(text, inferenceId) {
      if (!frame || !conversationId) return;
      const interaction = {
        message_type: "conversation",
        event_type: "conversation.echo",
        conversation_id: conversationId,
        properties: { modality: "text", text, done: true },
      };
      if (inferenceId) interaction.properties.inference_id = inferenceId;
      frame.sendAppMessage(interaction, "*");
    }

    function enqueueEcho(text, inferenceId) {
      if (!text || !String(text).trim()) return;
      echoQueue.push({ text: String(text), inferenceId });
      logLine(`Queued echo (${echoQueue.length}) → "${String(text).slice(0, 80)}${String(text).length > 80 ? "…" : ""}"`);
      pumpEchoQueue();
    }

    function afterEchoIdle(fn) {
      if (typeof fn !== "function") return;
      onEchoIdleCallbacks.push(fn);
      pumpEchoQueue();
    }

    function runEchoIdleCallbacksIfReady() {
      if (echoQueue.length === 0 && !echoSending && !replicaSpeaking) {
        const callbacks = onEchoIdleCallbacks.slice();
        onEchoIdleCallbacks = [];
        callbacks.forEach((cb) => {
          try { cb(); } catch (e) { logLine(`afterEchoIdle callback error: ${e}`); }
        });
      }
    }

    function pumpEchoQueue() {
      if (echoSending) return;

      // If replica is talking (and we know it), wait.
      if (replicaSpeaking) {
        runEchoIdleCallbacksIfReady();
        return;
      }

      if (echoQueue.length === 0) {
        runEchoIdleCallbacksIfReady();
        return;
      }

      const now = Date.now();
      if (now < nextSendNotBefore) {
        setTimeout(pumpEchoQueue, Math.max(60, nextSendNotBefore - now));
        return;
      }

      const item = echoQueue.shift();
      echoSending = true;

      try {
        sendEchoNow(item.text, item.inferenceId);
        logLine(`Sent echo → "${item.text.slice(0, 120)}${item.text.length > 120 ? "…" : ""}"`);
      } catch (e) {
        logLine(`Failed to send echo: ${e}`);
      }

      const holdMs = estimateSpeechMs(item.text);
      nextSendNotBefore = Date.now() + holdMs;

      // Release sending lock and try the next message after the hold.
      setTimeout(() => {
        echoSending = false;
        pumpEchoQueue();
        runEchoIdleCallbacksIfReady();
      }, holdMs);
    }

    // =========================================================
    // Round-robin engine
    // =========================================================
    function buildQueue(strategy = "joined") {
      const people = getHumanParticipants();
      if (!people.length) return [];

      if (strategy === "random") {
        const ids = people.map(p => p.id);
        for (let i = ids.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [ids[i], ids[j]] = [ids[j], ids[i]];
        }
        return ids;
      }

      if (strategy === "least_active_first") {
        people.forEach((p) => {
          const key = p.id || `name:${p.name.toLowerCase()}`;
          if (!speakCounts[key]) speakCounts[key] = { id: p.id, name: p.name, count: 0 };
        });

        const scored = people.map((p) => {
          const key = p.id || `name:${p.name.toLowerCase()}`;
          return { id: p.id, count: speakCounts[key]?.count || 0 };
        });

        scored.sort((a, b) => a.count - b.count);
        return scored.map(s => s.id);
      }

      return people.map(p => p.id);
    }

    function beginRound(stepKey, promptFn, opts = {}) {
      roundState.active = true;
      roundState.stepKey = stepKey;
      roundState.promptFn = promptFn;
      roundState.completed = new Set();
      roundState.responses = [];
      roundState.allowOutOfOrder = opts.allowOutOfOrder ?? true;
      roundState.queue = buildQueue(opts.queueStrategy || "least_active_first");
      
      // Determine first prompt
      let firstPrompt = "";
      let firstId = null;
      
      if (roundState.queue.length > 0) {
        firstId = roundState.queue[0];
        const p = participants[firstId];
        if (p) {
             firstPrompt = promptFn(p.name || "there");
        }
      }

      // Combine intro text and first prompt
      const intro = opts.introText || "";
      const fullScript = [intro, firstPrompt].filter(Boolean).join(" ");
      
      if (fullScript) {
          enqueueEcho(fullScript, opts.inferenceId);
      }

      roundState.currentId = firstId;
      roundState.pendingStart = false; // No need to wait, we combined them

      logLine(`Round started: ${stepKey} with ${roundState.queue.length} participants. Prompted first: ${firstId}`);
    }

    function triggerNextPhase(currentPhase) {
      let nextTool = null;

      if (currentPhase === "intro") nextTool = "start_picnic_game";
      else if (currentPhase === "picnic_game") nextTool = "start_morning_enjoyment_round";
      else if (currentPhase === "morning_enjoyment") nextTool = "start_fun_skill_round";
      else if (currentPhase === "fun_skill") nextTool = "start_shared_preference_task";
      else if (currentPhase === "shared_preference_tea_coffee") nextTool = "transition_to_next_session";

      if (nextTool) {
        logLine(`Auto-advancing to ${nextTool} after echo queue is idle...`);
        afterEchoIdle(() => {
          logLine(`Executing auto-advance to ${nextTool}`);
          handleToolCall({ properties: { name: nextTool } });
        });
      }
    }

    function promptNext() {
      if (!roundState.active) return;
      if (roundState.pendingStart) return;

      const nextId = roundState.queue.find(id => !roundState.completed.has(id));
      if (!nextId) {
        roundState.active = false;
        roundState.currentId = null;

        const phaseName = roundState.stepKey.replace(/_/g, " ");
        enqueueEcho(`Thanks everyone — the ${phaseName} round is complete.`);

        logLine(`Round finished: ${roundState.stepKey}`);

        // only trigger the next phase when the completion echo has finished
        triggerNextPhase(roundState.stepKey);
        return;
      }

      roundState.currentId = nextId;
      const p = participants[nextId];
      const promptText = roundState.promptFn?.(p?.name || "there") || "";
      if (promptText) enqueueEcho(promptText);
      logLine(`Prompted next: ${p?.name || nextId}`);
    }

    function markComplete(participant_id, display_name, text) {
      logLine(`Marked complete: ${display_name}`);
      roundState.completed.add(participant_id);
      roundState.responses.push({
        stepKey: roundState.stepKey,
        participant_id,
        display_name,
        text,
        ts: Date.now(),
      });
    }

    function resetRound() {
      roundState.active = false;
      roundState.stepKey = null;
      roundState.queue = [];
      roundState.currentId = null;
      roundState.completed = new Set();
      roundState.responses = [];
      roundState.promptFn = null;
      roundState.allowOutOfOrder = true;
      roundState.pendingStart = false;
    }

    // =========================================================
    // Tool calls
    // =========================================================
    function handleToolCall(event) {
      const { properties = {}, inference_id: inferenceId, conversation_id: convId } = event || {};
      if (convId && !conversationId) conversationId = convId;
      const toolName = properties.name;

      if (toolName === "get_current_speaker") {
        const { name, confident } = currentSpeaker();
        if (name && confident) {
          logLine(`Acknowledging current speaker: ${name}`);
          enqueueEcho(`Acknowledged: ${name} has spoken.`, inferenceId);

          // Optional fallback advancement if tool calls come reliably:
          if (roundState.active && lastSpokenPeerId) {
            const p = participants[lastSpokenPeerId];
            if (p && p.name === name) {
              const isExpected = lastSpokenPeerId === roundState.currentId;
              if ((isExpected || roundState.allowOutOfOrder) && !roundState.completed.has(lastSpokenPeerId)) {
                logLine(`Advancing round via get_current_speaker for ${name}`);
                markComplete(lastSpokenPeerId, name, "(implied by tool call)");
                promptNext(); // queues next prompt (won't cut off)
              }
            }
          }
        }
        return;
      }

      if (toolName === "get_least_active_participant") {
        const least = leastActiveParticipant();
        if (least?.name) {
          logLine(`Identifying least active participant: ${least.name}`);
          enqueueEcho(`Call on ${least.name} next.`, inferenceId);
        }
        return;
      }

      if (toolName === "initiate_introduction") {
        if (executedPhases.has("intro")) {
          logLine("Ignoring duplicate initiate_introduction");
          return;
        }
        executedPhases.add("intro");
        logLine("Tool call received: initiate_introduction. Echoing intro script.");

        const namesText = namesTextFromParticipants();
        const script =
          `Hi ${namesText}, welcome. I’m TeamWise. I’m not human — but I’m very good at helping humans work well together. ` +
          `We’ll start with a few short, light exercises. Nothing to prepare, nothing to get right — just a way to warm up, ` +
          `hear each other’s voices, and get comfortable as a group. I’ll guide us through everything.`;

        enqueueEcho(script, inferenceId);

        // Next phase only after the intro has finished playing
        triggerNextPhase("intro");
        return;
      }

      if (toolName === "start_picnic_game") {
        if (executedPhases.has("picnic")) {
          logLine("Ignoring duplicate start_picnic_game");
          return;
        }
        executedPhases.add("picnic");
        logLine("Tool call received: start_picnic_game. Echoing picnic game script + starting round-robin.");

        const script =
          `Let’s start with names in a playful way. Please say your name and something you’d bring to a picnic that starts ` +
          `with the same letter — and briefly why. Before adding your own, repeat the names and picnic items of everyone who spoke ` +
          `before you. I’ll start. I'm TeamWise, and I would bring Teamwork, because it helps us succeed.`;

        // For the chain game, strict order is better:
        beginRound(
          "picnic_game",
          (name) => `${name}, you’re up — say your name + picnic item (same first letter), and repeat the chain first.`,
          { queueStrategy: "joined", allowOutOfOrder: false, introText: script, inferenceId }
        );
        return;
      }

      if (toolName === "start_morning_enjoyment_round") {
        if (executedPhases.has("morning")) {
          logLine("Ignoring duplicate start_morning_enjoyment_round");
          return;
        }
        executedPhases.add("morning");
        logLine("Tool call received: start_morning_enjoyment_round. Echoing script + starting round-robin.");
        const script = `Great. Let’s do a quick round. What’s one thing you enjoy in the morning?`;

        beginRound(
          "morning_enjoyment",
          (name) => `${name}, what’s one thing you enjoy in the morning?`,
          { queueStrategy: "least_active_first", allowOutOfOrder: true, introText: script, inferenceId }
        );
        return;
      }

      if (toolName === "start_fun_skill_round") {
        if (executedPhases.has("fun_skill")) {
          logLine("Ignoring duplicate start_fun_skill_round");
          return;
        }
        executedPhases.add("fun_skill");
        logLine("Tool call received: start_fun_skill_round. Echoing script + starting round-robin.");
        const script =
          `One more individual round. What’s a fun skill you have? This can be something very small or ordinary — nothing impressive required.`;

        beginRound(
          "fun_skill",
          (name) => `${name}, what’s a fun skill you have?`,
          { queueStrategy: "least_active_first", allowOutOfOrder: true, introText: script, inferenceId }
        );
        return;
      }

      if (toolName === "start_shared_preference_task") {
        if (executedPhases.has("shared_pref")) {
          logLine("Ignoring duplicate start_shared_preference_task");
          return;
        }
        executedPhases.add("shared_pref");
        logLine("Tool call received: start_shared_preference_task. Echoing script + starting round-robin.");
        const script =
          `To finish, let’s do something together. I’ll suggest a few options, and we’ll see if we can find one thing we all like. ` +
          `You can just say yes or no — no explanations needed. How about... tea or coffee?`;

        beginRound(
          "shared_preference_tea_coffee",
          (name) => `${name}, tea or coffee? (Just say one.)`,
          { queueStrategy: "least_active_first", allowOutOfOrder: true, introText: script, inferenceId }
        );
        return;
      }

      if (toolName === "transition_to_next_session") {
        if (executedPhases.has("transition")) {
          logLine("Ignoring duplicate transition_to_next_session");
          return;
        }
        executedPhases.add("transition");
        logLine("Tool call received: transition_to_next_session. Echoing transition script.");

        enqueueEcho(
          `Perfect. We’ve learned each other’s names, shared a few small things, and found some common ground. ` +
          `Let’s take this relaxed, open mindset into the next session.`,
          inferenceId
        );

        resetRound();
        return;
      }

      if (toolName === "get_roster") return;
      logLine(`Unhandled tool_call ${toolName || "<unknown>"}`);
    }

    // =========================================================
    // Daily wiring
    // =========================================================
    function wireEvents(call) {
      call.on("participant-joined", (ev) => registerRoster(ev.participant, false));
      call.on("participant-updated", (ev) => registerRoster(ev.participant, false));

      call.on("active-speaker-change", (ev) => {
        lastActivePeerId = ev.activeSpeaker?.peerId || null;
        const p = participantFromId(lastActivePeerId) || ev.activeSpeaker;
        if (p) registerRoster(p, true);
      });

      call.on("transcription-started", () => logLine("Captions ON"));
      call.on("transcription-stopped", () => logLine("Captions OFF"));

      call.on("transcription-message", (ev) => {
        const msg = ev.message || ev;
        const text = msg.text || "";
        const speaker = msg.participant || participantFromId(lastActivePeerId);
        const speakerId =
          speaker?.session_id ||
          speaker?.peerId ||
          speaker?.id ||
          (typeof msg.participant === "string" ? msg.participant : null) ||
          null;

        if (text) {
          const label =
            speaker?.user_name ||
            speaker?.name ||
            speaker?.user_id ||
            participantFromId(lastActivePeerId)?.name ||
            lastSpokenName ||
            "Unknown";
          logLine(`[CC] ${label}: ${text}${msg.is_final ? "" : " (interim)"}`);
        }

        if (!speaker) return;

        // Track last spoken on both interim and final
        lastSpokenPeerId = speakerId || lastSpokenPeerId;
        lastSpokenName = speaker?.user_name || speaker?.name || speaker?.user_id || lastSpokenName;

        if (msg.is_final) {
          registerRoster({ ...(speaker || {}), id: speakerId }, true);
          bumpSpeakCount(speakerId, lastSpokenName);

          // "What's my name?" helper
          const textLower = (text || "").toLowerCase();
          if ((textLower.includes("what") && textLower.includes("my name")) ||
              (textLower.includes("who") && textLower.includes("am i")) ||
              (textLower.includes("my name"))) {
            if (lastSpokenName) enqueueEcho(`You are ${lastSpokenName}`);
          }

          // Round-robin advancement
          if (roundState.active && speakerId && participants[speakerId] && !isFacilName(participants[speakerId].name)) {
            const spokenText = (text || "").trim();
            if (spokenText.length > 1) {
              const isExpected = speakerId === roundState.currentId;

              if (isExpected || roundState.allowOutOfOrder) {
                if (!roundState.completed.has(speakerId)) {
                  const displayName = participants[speakerId]?.name || lastSpokenName || "Unknown";
                  markComplete(speakerId, displayName, spokenText);

                  // Queue thanks + next prompt (won't cut off)
                  enqueueEcho(`Thanks, ${displayName}.`);
                  promptNext();
                }
              } else {
                const expectedName = participants[roundState.currentId]?.name || "the next person";
                logLine(`Strict round: heard ${participants[speakerId]?.name}, waiting for ${expectedName}`);
              }
            }
          }
        }

        // Speaker hint for the model/tools
        try {
          frame.sendAppMessage({
            event_type: "conversation.speaker_hint",
            conversation_id: conversationId,
            properties: {
              participant_id: speakerId || "",
              display_name: lastSpokenName || "",
              confident: Boolean(lastSpokenName),
            },
          }, "*");
        } catch (e) {}
      });

      // Tavus tool calls + replica speaking lifecycle
      call.on("app-message", (ev) => {
        const data = ev?.data || {};

        if (data?.event_type === "conversation.tool_call") {
          logLine(`Tool call received: ${data?.properties?.name || "<unknown>"}`);
          handleToolCall(data);
          return;
        }

        // Best-effort lifecycle (names vary; keep both)
        if (data?.event_type === "conversation.replica.started_speaking" || data?.event_type === "conversation.replica.start_speaking") {
          replicaSpeaking = true;
          logLine("Replica started speaking.");
          return;
        }

        if (data?.event_type === "conversation.replica.stopped_speaking" || data?.event_type === "conversation.replica.stop_speaking") {
          replicaSpeaking = false;
          logLine("Replica stopped speaking.");
          pumpEchoQueue();
          runEchoIdleCallbacksIfReady();
          return;
        }
      });
    }

    joinBtn.addEventListener("click", async () => {
      const url = convoInput.value.trim();
      const name = nameInput.value.trim() || "Guest";
      conversationId = parseConversationId(url);

      if (!url || !conversationId) {
        logLine("Invalid conversation URL");
        return;
      }

      joinBtn.disabled = true;
      logLine(`Joining ${url} as ${name}`);

      if (frame) {
        try { await frame.leave(); } catch (e) {}
      }

      frame = window.DailyIframe.createFrame(document.getElementById("call"), {
        showLeaveButton: true,
        iframeStyle: { width: "100%", height: "100%", border: "0" },
      });

      wireEvents(frame);

      try {
        await frame.join({ url, userName: name });
        logLine("Joined meeting. Talk in two tabs to see diarization.");
        registerRoster(frame?.participants().local, true);
      } catch (err) {
        logLine(`Join failed: ${err}`);
        joinBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
