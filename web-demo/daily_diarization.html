<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Daily + Tavus diarization helper</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 16px; line-height: 1.4; background: #0b1021; color: #f2f4ff; }
    h1 { margin: 0 0 12px; font-size: 22px; }
    label { display: block; margin: 8px 0 4px; font-weight: 600; }
    input { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid #29304a; background: #11172f; color: #f2f4ff; }
    button { margin-top: 12px; padding: 10px 14px; border: none; border-radius: 8px; background: #4fd1c5; color: #0b1021; font-weight: 700; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 8px; }
    @media (min-width: 900px) { .row { grid-template-columns: 320px 1fr; } }
    #call { width: 100%; min-height: 500px; background: #0e152d; border: 1px solid #1c2540; border-radius: 10px; overflow: hidden; }
    #log { background: #0e152d; border: 1px solid #1c2540; border-radius: 10px; padding: 10px; height: 260px; overflow-y: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .note { font-size: 13px; color: #9eb0e0; margin-top: 6px; }
  </style>
  <script src="https://unpkg.com/@daily-co/daily-js"></script>
</head>
<body>
  <h1>Daily diarization → Tavus roster helper</h1>
  <div class="row">
    <div>
      <label for="conversation-url">Conversation URL (from tune.py)</label>
      <input id="conversation-url" placeholder="https://tavus.daily.co/abcdef123456" />
      <label for="webhook-base">Webhook base (FastAPI)</label>
      <input id="webhook-base" value="http://localhost:8000" />
      <label for="display-name">Your display name</label>
      <input id="display-name" placeholder="Alex" />
      <button id="join-btn">Join and listen</button>
      <div class="note">Ensure the conversation config has enable_closed_captions=true. Start your FastAPI webhook (uvicorn app.main:app).</div>
      <div class="note">We post participant info to /roster/register to keep Tavus tools diarization-aware.</div>
    </div>
    <div id="call"></div>
  </div>
  <label style="margin-top:16px;">Event log</label>
  <div id="log"></div>

  <script>
    const logEl = document.getElementById("log");
    const convoInput = document.getElementById("conversation-url");
    const webhookInput = document.getElementById("webhook-base");
    const nameInput = document.getElementById("display-name");
    const joinBtn = document.getElementById("join-btn");

    let frame = null;
    let conversationId = null;
    let participants = {};
    let lastActivePeerId = null;
    let lastSpokenPeerId = null;
    let lastSpokenName = null;
    let speakCounts = {};
    let lastRosterSnapshot = null;
    let startScriptSent = false;
    let rosterEchoSent = false;

    function logLine(msg) {
      const line = document.createElement("div");
      line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function parseConversationId(url) {
      try {
        const u = new URL(url);
        const parts = u.pathname.split("/").filter(Boolean);
        return parts[0] || null;
      } catch (e) {
        return null;
      }
    }

    function rememberParticipant(p) {
      if (!p) return null;
      const id = p.session_id || p.peerId || p.id || null;
      const name = p.user_name || p.name || p.user_id || (id ? `user-${id.slice(-5)}` : "Unknown");
      if (id) participants[id] = { id, name };
      const key = id || (name ? `name:${name.toLowerCase()}` : null);
      if (key) {
        const existing = speakCounts[key] || { id, name, count: 0 };
        speakCounts[key] = { ...existing, id: id || existing.id, name: name || existing.name };
      }
      return id ? { id, name } : null;
    }

    function bumpSpeakCount(id, name) {
      const key = id || (name ? `name:${name.toLowerCase()}` : null);
      if (!key) return;
      const existing = speakCounts[key] || { id, name, count: 0 };
      speakCounts[key] = { id: id || existing.id, name: name || existing.name, count: (existing.count || 0) + 1 };
    }

    async function registerRoster(p, active = false) {
      const entry = rememberParticipant(p);
      if (!entry || !conversationId) return;
      if (active) {
        lastSpokenPeerId = entry.id;
        lastSpokenName = entry.name;
        bumpSpeakCount(entry.id, entry.name);
      }
      const body = {
        conversation_id: conversationId,
        display_name: entry.name,
        participant_id: entry.id,
        active,
      };
      try {
        const base = webhookInput.value.replace(/\/$/, "");
        await fetch(`${base}/roster/register`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        logLine(`Roster updated: ${entry.name} (${entry.id})${active ? " [active]" : ""}`);
      } catch (err) {
        logLine(`Failed to POST /roster/register: ${err}`);
      }
    }

    function participantFromId(id) {
      return participants[id] || null;
    }

    function currentSpeaker() {
      // Only return a name when it came from the most recent spoken turn
      if (lastSpokenPeerId && participants[lastSpokenPeerId]) {
        return { name: participants[lastSpokenPeerId].name, confident: true };
      }
      if (lastSpokenName) {
        return { name: lastSpokenName, confident: true };
      }
      return { name: "", confident: false };
    }

    function leastActiveParticipant() {
      const facilKeywords = ["assistant", "facilitator", "meeting facilitator", "teamwise"];
      const isFacil = (nm) => facilKeywords.some((k) => nm?.toLowerCase().includes(k));
      // Seed counts with known participants (default 0)
      Object.values(participants).forEach((p) => {
        const key = p.id || (p.name ? `name:${p.name.toLowerCase()}` : null);
        if (key && !speakCounts[key]) {
          speakCounts[key] = { id: p.id, name: p.name, count: 0 };
        }
      });
      const entries = Object.values(speakCounts).filter((e) => e && e.name && !isFacil(e.name));
      if (!entries.length) {
        const fallback = Object.values(participants).find((p) => p.name && !isFacil(p.name));
        return fallback ? { ...fallback, count: 0 } : null;
      }
      entries.sort((a, b) => (a.count || 0) - (b.count || 0));
      return entries[0];
    }

    function sendEcho(text, inferenceId) {
      if (!frame || !conversationId) return;
      const interaction = {
        message_type: "conversation",
        event_type: "conversation.echo",
        conversation_id: conversationId,
        properties: {
          modality: "text",
          text,
          done: true,
        },
      };
      if (inferenceId) interaction.properties.inference_id = inferenceId;
      try {
        frame.sendAppMessage(interaction, "*");
        logLine(`Sent echo → "${text}"`);
      } catch (e) {
        logLine(`Failed to send echo: ${e}`);
      }
    }

    function handleToolCall(event) {
      const { properties = {}, inference_id: inferenceId, conversation_id: convId } = event || {};
      if (convId && !conversationId) conversationId = convId;
      const toolName = properties.name;
      if (toolName === "get_current_speaker") {
        const { name, confident } = currentSpeaker();
        if (name && confident) {
          sendEcho(`Thanks for sharing that, ${name}.`, inferenceId);
        }
        return;
      }
      if (toolName === "get_speaker_name") {
        const { name, confident } = currentSpeaker();
        if (name ) {
          sendEcho(name, inferenceId);
        }
        return;
      }
      if (toolName === "get_roster") {
        if (!startScriptSent) {
          const facilKeywords = ["assistant", "facilitator", "meeting facilitator", "teamwise"];
          const filtered = Object.values(participants)
            .map((p) => p.name)
            .filter((nm) => nm && !facilKeywords.some((k) => nm.toLowerCase().includes(k)));
          const rosterNames = filtered.join(", ");
          if (rosterNames) {
            // Also send the full intro script via echo (tied to this inferenceId for reliability)
            let namesText = "everyone";
            if (filtered.length === 1) namesText = filtered[0];
            else if (filtered.length === 2) namesText = `${filtered[0]} and ${filtered[1]}`;
            else if (filtered.length > 2) namesText = `${filtered.slice(0, -1).join(", ")}, and ${filtered[filtered.length - 1]}`;
            const pick = filtered.length ? filtered[Math.floor(Math.random() * filtered.length)] : "";
            const script = `Hi everyone, welcome. I'm glad to see ${namesText} here with us today. The goal of this short session is simple: it’s a chance for us to get to know each other a little better and create a good foundation for working together. To begin, I'd like us to create a shared starting point. We’ll go around and each person will say their name and one intention they have for today. Before sharing your own intention, please repeat the intention of the person before you — just as you heard it. I’ll start: I’m TeamWise, and my intention is to create the best group ever. ${pick ? `Would you like to go next, ${pick}?` : "Who would like to go next?"}`;
            sendEcho(script, inferenceId);
            startScriptSent = true;
          }
        }
        return;
      }
      if (toolName === "get_least_active_participant") {
        const least = leastActiveParticipant();
        if (least?.name) {
          sendEcho(`Call on ${least.name} next.`, inferenceId);
        }
        return;
      }
      logLine(`Unhandled tool_call ${toolName || "<unknown>"}`);
    }

    function wireEvents(call) {
      call.on("participant-joined", (ev) => {
        registerRoster(ev.participant, false);
      });
      call.on("participant-updated", (ev) => {
        registerRoster(ev.participant, false);
      });
      call.on("active-speaker-change", (ev) => {
        lastActivePeerId = ev.activeSpeaker?.peerId || null;
        const p = participantFromId(lastActivePeerId) || ev.activeSpeaker;
        if (p) registerRoster(p, true);
      });
      call.on("transcription-started", () => logLine("Captions ON"));
      call.on("transcription-stopped", () => logLine("Captions OFF"));
      call.on("transcription-message", (ev) => {
        const msg = ev.message || ev;
        const text = msg.text || "";
        const speaker = msg.participant || participantFromId(lastActivePeerId);
        const speakerId =
          speaker?.session_id ||
          speaker?.peerId ||
          speaker?.id ||
          (typeof msg.participant === "string" ? msg.participant : null) ||
          null;
        if (text) {
          const label =
            speaker?.user_name ||
            speaker?.name ||
            speaker?.user_id ||
            participantFromId(lastActivePeerId)?.name ||
            lastSpokenName ||
            "Unknown";
          logLine(`[CC] ${label}: ${text}${msg.is_final ? "" : " (interim)"}`);
        }
        if (speaker) {
          // Track last spoken on both interim and final to keep current speaker accurate
          lastSpokenPeerId = speakerId || lastSpokenPeerId;
          lastSpokenName =
            speaker?.user_name ||
            speaker?.name ||
            speaker?.user_id ||
            lastSpokenName;
          if (msg.is_final) {
            registerRoster({ ...(speaker || {}), id: speakerId }, true);
            bumpSpeakCount(speakerId, lastSpokenName);
            // Start script trigger
            const t = (text || "").toLowerCase();
            if (!startScriptSent && (t.includes("start") || t.includes("we can start"))) {
              const facilKeywords = ["assistant", "facilitator", "meeting facilitator", "teamwise"];
              const names = Object.values(participants)
                .map((p) => p.name)
                .filter((nm) => nm && !facilKeywords.some((k) => nm.toLowerCase().includes(k)));
              let namesText = "everyone";
              if (names.length === 1) {
                namesText = names[0];
              } else if (names.length === 2) {
                namesText = `${names[0]} and ${names[1]}`;
              } else if (names.length > 2) {
                namesText = `${names.slice(0, -1).join(", ")}, and ${names[names.length - 1]}`;
              }
              const pick = names.length ? names[Math.floor(Math.random() * names.length)] : "";
              startScriptSent = true;
              rosterEchoSent = true;
            }
            // Check if participant asked "what's my name?" and send identity echo
            const textLower = text.toLowerCase();
            if ((textLower.includes("what") && textLower.includes("my name")) ||
                (textLower.includes("who") && textLower.includes("am i")) ||
                (textLower.includes("my name"))) {
              if (lastSpokenName) {
                sendEcho(`You are ${lastSpokenName}`);
              }
            }
          }
          // Emit an app-message hint with the latest speaker for the model/tools
          try {
            frame.sendAppMessage({
              event_type: "conversation.speaker_hint",
              conversation_id: conversationId,
              properties: {
                participant_id: speakerId || "",
                display_name: lastSpokenName || "",
                confident: Boolean(lastSpokenName),
              },
            }, "*");
          } catch (e) {
            // ignore
          }
        }
      });
      // Listen for interactions protocol over app-message (Tavus tool calls)
      call.on("app-message", (ev) => {
        const data = ev?.data || {};
        if (data?.event_type === "conversation.tool_call") {
          logLine(`Tool call received: ${data?.properties?.name || "<unknown>"}`);
          handleToolCall(data);
        }
      });
    }

    joinBtn.addEventListener("click", async () => {
      const url = convoInput.value.trim();
      const name = nameInput.value.trim() || "Guest";
      conversationId = parseConversationId(url);
      if (!url || !conversationId) {
        logLine("Invalid conversation URL");
        return;
      }
      joinBtn.disabled = true;
      logLine(`Joining ${url} as ${name}`);
      if (frame) {
        try { await frame.leave(); } catch (e) {}
      }
      frame = window.DailyIframe.createFrame(document.getElementById("call"), {
        showLeaveButton: true,
        iframeStyle: { width: "100%", height: "100%", border: "0" },
      });
      wireEvents(frame);
      try {
        await frame.join({ url, userName: name });
        logLine("Joined meeting. Talk in two tabs to see diarization.");
        // Register local participant immediately so the persona knows your name even before you speak
        registerRoster(frame?.participants().local, true);
      } catch (err) {
        logLine(`Join failed: ${err}`);
        joinBtn.disabled = false;
      }
    });
  </script>
</body>
</html>
